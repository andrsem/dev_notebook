# Testing

## Principles of Good Unit Testing by Robert Martin

FIRST

### Fast

Tests should be fast-running. A whole suite of unit tests should take seconds to run. The faster the tests, the more of them you can have in the suite, and the more often you can run them. When tests are slow, your team will not run them frequently. As a result, you may not find problems early enough to fix them easily

### Independent

Tests should not be dependent on each other. One test should not set conditions for the next. You team members should be able to run each test independently and in any order. When tests depend on each other, the first one to fail causes a cascade of downstream failures

### Repeatable

Tests should be repeatable in any environment. If unit tests pass when running one-by-one but fail when running the whole test suite, or if they pass on your development machine but fail on the CI server, there's a design flaw. Your team should be able to successfully run the tests on the production environment, QA environment and development environment

### Self-Validating

Tests should have a Boolean output and either pass or fail. The same test that fails now and passes later is __flaky__ and compromises the whole testing suite. Flaky tests lead to negative consequences. Developers stop trusting tests and start ignoring them, and it becomes challenging to identify non-flaky tests that fail in a sea of flaky tests.

### Timely

Unit tests should be written in a timely manner - before or at the same time as the production code. Testing post facto requires developers to refactor the working code and make additional efforts to have tests fulfilling FIRST principles

## Other Attributes of Good Unit Tests

### Maintainable

Being maintainable means that unit test code is considered just as important as production code. If you want your team's production code to be easy to maintain, you must keep your unit tests easy to maintain as well

A properly written test should allow a reader to quickly understand the logic/intention of the test and jump to the erroneous production code immediately. A good unit test is short, structured, simple and makes the development process faster

### Isolated

A good unit test should be isolated from any external dependency (e.g., database, file system, environment settings, network). When you involve these external systems, your unit tests can fail for environmental reason that have nothing to do with your production code

### Properly Targeted

A successful test suite targets only the essential parts of the production codebase on a project. For this reason, it is important to differentiate the heart of the application from the rest - its domain model. Based on the implemented logic, production code is classified into three types:

#### Practically Unit-Testable

- Core functions: business calculations, algorithms, reused (platform) code, etc

#### Unit-Testable in Theory

- Volatile code: UI controls/styles or unstable prototype (POC) code. Changing code will likely result in test failures that are not bugs
- Difficult to write unit tests: multi-threaded code, application bootstrapping, autogenerated code, etc. Sometimes unit testing is just not a good fit for verification, and it makes more sense to test on other levels of automated testing (e.g. integration testing)

#### Intentionally Unit-Untestable

- Interactions with external dependencies: network, database, file system, etc.
- Boilerplate and trivial code: getter/setter, setup wiring, annotations, etc.

To maximize the efficiency of unit testing, your team should write only the tests whose value exceeds their cost

## Types of Testing

- sanity testing - determines if modifications to code have fixed issues without introducing new ones
- smoke testing - verifies if basic functionalities work or not
- regression testing - ensures that changes haven't broken existing functionality
- UI testing - replicates how a user interacts with an application and checks all the system layers
- performance testing - determines how a system performs under a particular workload
- API testing - checks the functionality, reliability, performance and security of APIs
